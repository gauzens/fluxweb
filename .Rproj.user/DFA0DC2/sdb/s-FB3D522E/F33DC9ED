{
    "collab_server" : "",
    "contents" : "#' generate fluxes\n#'\n#' create a valuated graph adjacency matrix from its binary version\n#'\n#' @param mat Network adjacency matrix describing interactions among species. Interactions can be either binary or weighted.\n#' @param losses A vector or an array of species energy losses (excluding predation).\n#' @param biomasses Vector of species biomasses.\n#' @param efficiencies A vector or an array of conversion efficiencies of species in the adjacency matrix. These values describe the proportion of consumed energy that is converted to biomass of the consumer.\n#' @param bioms.prefs Logical - if \\code{TRUE}, consumer preferences are scaled according to species biomasses.\n#' @param bioms.losses Logical - if \\code{TRUE}, losses are scaled with species biomasses.\n#' @param ef.level Set to \\code{\"prey\"} if efficiences are defined by prey, \\code{\"pred\"} if they are a property of the predator.\n#'\n#'\n#' @return Returns an adjacency matrix where entries are the computed energy fluxes between consumer species and their respective resources.\n#'\n#'\n#'@details\n#'This function compute fluxes in food webs based on an equilibrium hypothesis: for each species, sum of ingoing fluxes (gains from predation) balances the sum of outgoing fluxes.\n#'Outgoing fluxes are defined by predation and \\code{losses} argument. Ususally \\code{losses} relate to species metabolic rates and/or natural death rates. for each species \\code{i}, sum of ingoing fluxes \\code{F_i} is computed as:\n#'\\deqn{\n#'F_{i} = \\frac{1}{e_i} (L_i + \\sum_j W_{ij}F_j) \\quad if \\quad \\code{ef.level == \"pred\"}\n#'}\n#'\\deqn{\n#'F_{i} = \\frac{L_i + \\sum_j W_{ij}F_j}{\\sum_j W_{ji}e_j} \\quad if \\quad \\code{ef.level == \"pred\"}\n#'}\n#'\\code{W} set the matrix of preferences estimated from \\code{mat}, accordingly to \\code{bioms.prefs}. \\code{L} is the vector depicting sum of losses\n#'(scaled or not by biomasses, accordingly to \\code{bioms.losses}) and \\code{e} is the vector of species efficiencies.\n#'\n#'\n#'\\itemize{\n#'\\item{\\code{mat}:} Either a binary or a valuated matrix can be used. A non zero value for mat[i,j] means that species i is consumed by species j.\n#'Matrix entries would assess predator preferences on its prey, thus providing a binary matrix assume no preferences.\n#'\n#'\\item{\\code{losses}:} express species energetic losses not related to predation. Usually metabolic or death rates.\n#'When an array is provided, losses associated to each species correspond to line sums.\n#'\n#'\\item{\\code{efficiencies}:} Determines how efficient species are to convert energy (see \\code{ef.level} for more details).\n#'Providing an array will assume values depending on both prey and predator identity\n#'\n#'\\item{\\code{bioms.pref}:} If \\code{TRUE}, preferences \\eqn{W_{ij}} of predator j on prey i are scaled accordingly to species biomass unsing the following formula:\n#'\\deqn{\n#'W_{i,j} = \\frac{mat[i,j] * biomasses[i]}{\\sum_k mat[i,k]* biomasses[k]}\n#'}\n#'If \\code{FALSE}, a mormalisation on column values is performed.\n#'\n#'\\item{\\code{bioms.losses}:} Set to true, function will assume that losses are defined per biomass unit.\n#'Thus, total losses will be thereafter multiplied by biomass values for each species.\n#'\n#'\\item{\\code{ef.level}:} if \\code{\"prey\"} (resp \\code{\"pred\"}), the total amount of energy that can be metabolised from a trophic link\n#'will be determined by prey (resp pred) identity. \\code{\"link.specific\"} assumes that efficiencies are defined for each trophic interaction\n#'and ask \\code{efficiencies} parameter to be a matrix\n#'\n#'}\n#'\n#'\n#' @examples\n#' # first compute species per unit biomass metabolic rates using the metabolic theory:\n#'losses = 0.1 * species.level$bodymasses^(-0.25)\n#'\n#' # Then assess prey efficiencies (0.35 for basal species, 0.85 for non basal)\n#'efficiencies = rep(NA, length(species.level$names))\n#'efficiencies[colSums(species.level$mat) == 0] = 0.35\n#'efficiencies[colSums(species.level$mat) > 0] = 0.85\n#'\n#'# call of the function:\n#'fluxing(species.level$mat, species.level$biomasses, losses, efficiencies, bioms.pref = TRUE, ef.level = \"prey\")\n#'\n#' @export\n#'\n#'\n#' @author Benoit gauzens, \\email{benoit.gauzens@gmail.com}\n\n\nfluxing = function(mat, biomasses = NULL, losses, efficiencies, bioms.prefs = TRUE, bioms.losses = TRUE, ef.level = \"prey\"){\n\n  # mat\n  if (! is.numeric(mat)){\n    stop(\"'mat' must be numeric\")\n  }\n  if (dim(mat)[1] != dim(mat)[2]){\n    stop(\"mat should be a square matrix\")\n  }\n\n  # biomasses\n  if (!is.null(biomasses)){\n    if (! is.vector(biomasses)){\n      stop(\"biomasses should be a vector\")\n    } else{\n      if (length(biomasses) != dim(mat)[1]){\n        stop(\"length of biomasses vector should equal to dimensions of mat\")\n      }\n    }\n    if (! is.numeric(biomasses)){\n      stop(\"'biomasses' must be numeric\")\n    } else if (any(biomasses < 0)){\n      stop(\"'biomasses' must be all >=0\")\n    }\n  } else if (bioms.prefs){\n    stop(\"bioms.prefs set to TRUE but no biomasses provided\")\n  }\n\n  # losses\n  if (! is.numeric(losses)){\n    stop(\"'losses' should be numeric\")\n  } else if (any(losses < 0)){\n    stop(\"'losses' contain negative value(s)\")\n  }\n\n  # efficiences\n  if (! is.numeric(efficiencies)){\n    stop(\"'efficiencies' must be numeric\")\n    if (!(any(efficiencies < 0) || any(efficiencies > 1))) {\n      stop(\"'efficiencies' must be all in interval [0,1]\")\n    }\n\n    if (is.vector(efficiencies)){\n      if (length(efficiencies) != dim(mat)[1]){\n        stop(\"'efficiencies' vector length sould be equal to number of species (dimension of mat)\")\n      }\n    } else if (dim(efficiencies != dim(mat))){\n      stop(\"'efficiencies' matrix dimension different from 'mat'\")\n    }\n  }\n\n  if (!(ef.level %in% c('prey', 'pred', 'link.specific'))){\n    stop(\"ef.level should be set to 'pred', 'prey' or 'link.specific'\")\n  }\n  if (ef.level == 'prey' && is.matrix(efficiencies)){ # if user did not change the ef.level = \"prey\" optional argument but provide a matrix for efficiencies:\n    warning(\"'ef.level' is set to 'prey' and expect a vector of efficiencies but get a matrix instead.\\n ef.level was then set to 'link.specific'\")\n    ef.level = 'link.specific'\n  }\n\n  ### first arrange mat: apply the biomass scaling of preferences if needed\n  ### columns should sum to 1 for predators, 0 to preys\n  column.sum = colSums(mat)\n  if (bioms.prefs){\n    # 'apply functional' response of preferencs\n    # mat[, column.sum > 0] = apply(mat[, column.sum > 0], 2, function(vec, bioms) vec*biomasses/sum(vec*biomasses), biomasses) #! in the function I should use bioms instead biomasses\n    mat[, column.sum > 0] = apply(mat[, column.sum > 0], 2, function(vec) vec*biomasses/sum(vec*biomasses)) #! in the function biomasses is already defined more globaly, so no need of another parameter\n\n      } else { # here optimise with else if not all element of colsums are equal to either 1 or 0...\n    # sum of entries have to sum to one for each predator (normalisaton of preferences)\n    colomn.sum = colSums(mat)\n    mat[, colomn.sum>0] = sweep(mat[, colomn.sum>0], 2, colomn.sum[colomn.sum>0], \"/\")\n  }\n\n  ### define loss vector as the sum of species losses:\n  # need to check data input much more carefully...\n  if (! is.vector(losses)){ # this is for allowing user to input a loss matrix (different kinds of physiological loss in the same parameter)\n    losses = rowSums(losses)\n  }\n  if (bioms.losses == T){\n    losses = losses*biomasses\n  }\n\n  ### then solving the system\n  # warning here: even if efficiencies are defined at the predator level I need a vector of legth = to number of species (with some arbitrary values for basal species)\n  # should be precised somewhere\n  if (ef.level == \"pred\"){\n    F = solve(diag(efficiencies) - mat) %*% losses\n  }\n  if (ef.level == \"prey\"){\n    vec.in = as.vector(t(mat) %*% efficiencies)\n    vec.1p = rep(0, dim(mat)[1])\n    vec.1p[colSums(mat) == 0] = 1\n    F = solve(diag(vec.in + vec.1p) - mat) %*% losses\n  }\n  if (ef.level == \"link.specific\"){\n    U = mat * efficiencies\n    vec.one = rep(1, dim(efficiencies)[1])\n    vec.1p = rep(0, dim(mat)[1])\n    vec.1p[colSums(mat) == 0] = 1\n    vec.in = as.vector(t(U)%*%vec.one + vec.1p)\n    F = solve(diag(vec.in) - mat) %*% losses\n  }\n\n\n  ### set individual fluxes (each element of ith line from mat.norm is multiplied bu the ith element of F)\n  flux.mat = sweep(mat, 2, F, \"*\")\n  return(flux.mat)\n}\n\n\n",
    "created" : 1506674543151.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2942514130",
    "id" : "F33DC9ED",
    "lastKnownWriteTime" : 1506668860,
    "last_content_update" : 1506668860,
    "path" : "~/projects/fluxing_webs/fluxweb/R/flux.function.R",
    "project_path" : "R/flux.function.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}