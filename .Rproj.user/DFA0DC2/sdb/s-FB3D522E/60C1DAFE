{
    "collab_server" : "",
    "contents" : "#' sensitivity analysis\n#'\n#' Assess how sensitive are results from argument function to variability of input parameter through coefficient of variation.\n#'\n#' @param fun.name Function to analyse.\n#' @param ... Arguments to be passed to \\code{fun.name}. Argument names must exactly match those of fun.name.\n#' @param param.name Parameter from \\code{...} on wich variation is applied.\n#' @param var Define the interval of incertainty for the uniform law around \\code{x} as \\code{[x - x*var, x + x*var]}.\n#' @param n Number of replicates.\n#' @param full.output logical, if \\code{TRUE} all of \\code{n} estimations of \\code{fun.name} are returned. Only their mean otherwise.\n#'\n#' @return mean coefficient of variation in comparison to non randomised inputs among all the replicates\n#'\n#' @details\n#'\n#' At each replicate, a coefficient of variation is computed (relatively to results obtained form \\code{fun.name} without random variation).\n#' if \\code{full.output} is \\code{FALSE} (default) an object of the same type as the one produced by \\code{fun.name} is returned, containing all of variation coefficients.\n#' If \\code{fill.output} is \\code{TRUE}, a list of size \\code{n} with of objects containing variation coeficient is returned.\n#'\n#' Argument for \\code{...} should be passed with their names.\n#'\n#' This approach is quite archaic... but its meaning is easy to get\n#'\n#'\n#' @examples\n#'\n\n#' # first compute species per unit biomass metabolic rates using the metabolic theory:\n#'losses = 0.1 * species.level$bodymasses^(-0.25)\n#'\n#' # Then assess prey efficiencies (0.35 for basal species, 0.85 for non basal)\n#'efficiencies = rep(0, length(species.level$names))\n#'efficiencies[colSums(species.level$mat) == 0] = 0.35\n#'efficiencies[colSums(species.level$mat) > 0] = 0.85\n#'\n#'\n#'res = sensitivity(fluxing, \"mat\", 0.1, 5, full.output = TRUE, mat = species.level$mat, biomasses = species.level$biomasses, losses = losses, efficiencies = efficiencies)\n#'res = sensitivity(fluxing, \"efficiencies\", 0.1, 50, mat = species.level$mat, biomasses = species.level$biomasses, losses = losses, efficiencies = efficiencies)\n#'\n#' # growth rates of basal sppecies\n#'growth.rate = rep(0.5, length(species.level$biomasses[colSums(species.level$mat) == 0]))\n#'\n#'val.mat = fluxing(species.level$mat, species.level$biomasses, losses, efficiencies)\n#'sensitivity(stability.value, \"efficiencies\", 0.1, 50, val.mat = val.mat, biomasses = species.level$biomasses, losses = losses, efficiencies = efficiencies, growth.rate = growth.rate)\n#'\n#'\n#'cvs = c()\n#'for (var in seq(0, 0.6, 0.05)){\n#'  cvs = c(cvs, sensitivity(stability.value, \"mat\", var, 50, val.mat = val.mat, biomasses = species.level$biomasses, losses = losses, efficiencies = efficiencies, growth.rate = growth.rate))\n#'}\n#'\n#'plot(abs(cvs) ~ seq(0, 0.6, 0.05))\n#'\n#' @export\n#'\n\n\nsensitivity = function(fun.name, param.name, var, n, full.output = FALSE, ...){\n  is.scalar = function(x){\n    return(is.vector(x) && length(x) == 1)\n  }\n  # get arguments for fun.name\n  args = list(...)\n  # store result from the function without any randomness\n  res.init = do.call(fun.name, args)\n  # creates vector of results\n  if (full.output){\n    if (is.scalar(res.init)){\n      res.output = rep(NA, n)\n    }else{\n      res.output = list()\n    }\n  }\n  vec.cv = rep(NA, n)\n  simple.res = 0\n  for (i in 1:n){\n\n    ## first, modification of the focal parameter\n    if (is.matrix(args[[param.name]])){\n      param = args[[param.name]]\n      # fill deviation matrix with uniform distribution in [-var, var]\n      deviation = matrix(stats::runif(dim(param)[1]*dim(param)[1], min = 1 - var, max = 1 + var), dim(param)[1], dim(param)[1])\n      # output = initial value * deviation\n      args[[param.name]] = args[[param.name]] * (deviation)\n    }\n\n    if (is.vector(args[[param.name]])){ # scalars are also vectors...\n      param = args[[param.name]]\n      # fill deviation vector with uniform distribution in [-var, var]\n      deviation = stats::runif(length(param), min = 1 - var, max = 1 + var)\n      # output = initial value * deviation\n      args[[param.name]] = args[[param.name]] * (deviation)\n      # print(args[[param.name]])\n    }\n\n    ## then call to the function\n    res = do.call(fun.name, args)\n    neutral.res = res.init\n    neutral.res[neutral.res == 0] = NA\n    # then, for this draw, departure is the coefficient of variation (base = results without random variation)\n    # for matrix or vector, I take the mean value of all cv\n    res.cv = abs((res - res.init)/neutral.res)\n\n\n    if (full.output){\n      if (is.scalar(res.init)){\n        res.output[i] = res.cv\n      }else{\n        res.output[[i]] = res.cv\n      }\n    }\n    #  sensitivity value is then the means of the coefficient of variation\n    simple.res = simple.res + res.cv/n\n\n  }\n  if (full.output){\n    return(res.output)\n  }else{\n    return(simple.res)\n  }\n\n}\n",
    "created" : 1506675034378.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "897201685",
    "id" : "60C1DAFE",
    "lastKnownWriteTime" : 1506672316,
    "last_content_update" : 1506672316,
    "path" : "~/projects/fluxing_webs/fluxweb/R/sensitivity.R",
    "project_path" : "R/sensitivity.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}