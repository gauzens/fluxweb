{
    "collab_server" : "",
    "contents" : "#' estimate network stability\n#'\n#' compute resiliance of the system through jacobian eigenvalues\n#'\n#'\n#' @param val.mat A matrix describing fluxes between species (usually a result of \\code{\\link[fluxweb]{fluxing}} function).\n#' @param biomasses A vector of species biomasses.\n#' @param losses A vector or an array of species energy losses (excluding predation).\n#' @param efficiencies A vector or an array of conversion efficiencies of species in the adjacency matrix. These values describe the proportion of consumed energy that is converted to biomass of the consumer.\n#' @param growth.rate A vector defining growth rate of basal species.\n#' @param bioms.prefs Logical, if \\code{TRUE} (default) preferences are scaled accordingly to species biomasses.\n#' @param bioms.losses Logical, if \\code{TRUE} (default) losses are scaled with biomass.\n#' @param ef.level Set to \\code{\"prey\"} if efficiences are defined by prey, \\code{\"pred\"} if they are a property of the predator.\n#' @param full.output Logical, if \\code{TRUE} function return supplementary informations\n#'\n#' @return maximum eigenvalue of the jacobian matrix of a lotka Voltera like system of equation If \\code{full.output}, Jacobian eigenvalues and eigenvectors are returned.\n#'\n#'\n#'@details\n#'\n#'\n#For more information about the set of the underlying system of differential equations and mathematical derivation, please read REF TO SI of the paper\n#'\n#'\n#'\\itemize{\n#'\n#'\\item{\\code{losses}:} express species energetic losses not related to predation. Usually metabolic or death rates.\n#'When an array is provided, losses associated to each species correspond to line sums.\n#'\n#'\\item{\\code{efficiencies}:} Determines how efficient species are to convert energy (see \\code{ef.level} for more details).\n#'Providing an array will assume values depending on both prey and predator identity\n#'\n#'\\item{\\code{growth.rate}:} Growth rates of basal species defined in \\code{growth.rate} should appear in the same order as in other arguments.\n#'For example the second value specified in \\code{growth.rate} should set the groth rate of the second basal species found in \\code{biomasses}. IS THAT CLEAR...\n#'\n#'\\item{\\code{bioms.pref}:} If \\code{TRUE}, preferences \\eqn{w_{ij}} of predator j on prey i are scaled accordingly to species biomass unsing the following formula:\n#'\\deqn{\n#'w_{i,j} = \\frac{mat[i,j] * biomasses[i]}{\\sum_k mat[i,k]* biomasses[k]}\n#'}\n#'\\item{\\code{bioms.losses}:} If \\code{TRUE}, function will assume that losses are defined per biomass unit.\n#'Thus, total losses will be thereafter multiplied by biomass values for each species.\n#'\n#'\\item{\\code{ef.level}:} if \\code{\"prey\"} (resp \\code{\"pred\"}), the total amount of energy that can be metabolised from a trophic link\n#'will be determined by prey (resp pred) identity. \\code{\"link.specific\"} assumes that efficiencies are defined for each trophic interaction\n#'and ask \\code{efficiencies} parameter to be a matrix\n#'\n#'\\item{\\code{full.output}:} If \\code{TRUE}, function result is a list of eigenvalues and eigenvectors of the jacobian matrix. (return also the jacobian?)\n#'\n#'}\n#'\n#'\n#'\n#' @examples\n# # first compute species per unit biomass metabolic rates using the metabolic theory:\n#' losses = 0.1 * species.level$bodymasses^(-0.25)\n#'\n#' # Then assess prey efficiencies (0.35 for basal species, 0.85 for non basal)\n#'efficiencies = rep(NA, length(species.level$names))\n#'efficiencies[colSums(species.level$mat) == 0] = 0.35\n#'efficiencies[colSums(species.level$mat) > 0] = 0.85\n#'\n#' # growth rates of basal sppecies\n#' growth.rates = rep(0.5, length(species.level$biomasses[colSums(species.level$mat) == 0]))\n#'\n#' val.mat = fluxing(species.level$mat, species.level$biomasses, losses, efficiencies, bioms.pref = TRUE, ef.level = \"pred\")\n#' stability.value(val.mat, species.level$biomasses, losses, efficiencies, growth.rates, ef.level = \"pred\")\n#'\n\n#' @author Benoit gauzens, \\email{benoit.gauzens@gmail.com}\n#'\n#' @export\n\n\nstability.value = function(val.mat,\n                           biomasses,\n                           losses,\n                           efficiencies,\n                           growth.rate,\n                           bioms.prefs = TRUE,\n                           bioms.losses = TRUE,\n                           ef.level = \"prey\",\n                           full.output = FALSE){\n\n  # mat\n  if (! is.numeric(val.mat)){\n    stop(\"'val.mat' must be numeric\")\n  }\n  if (dim(val.mat)[1] != dim(val.mat)[2]){\n    stop(\"val.mat should be a square matrix\")\n  }\n\n  # biomasses\n  if (! is.vector(biomasses)){\n    stop(\"biomasses should be a vector\")\n  } else{\n    if (length(biomasses) != dim(val.mat)[1]){\n      stop(\"length of biomasses vector should equal to dimensions of val.mat\")\n    }\n  }\n  if (! is.numeric(biomasses)){\n    stop(\"'biomasses' must be numeric\")\n  } else if (any(biomasses <= 0)){\n    stop(\"'biomasses' must be all >0\")\n  }\n\n  # losses\n  if (! is.numeric(losses)){\n    stop(\"'losses' should be numeric\")\n  } else if (any(losses < 0)){\n    stop(\"'losses' contain negative value(s)\")\n  }\n\n  # efficiences\n  if (! is.numeric(efficiencies)){\n    stop(\"'efficiencies' must be numeric\")\n    if (!(any(efficiencies < 0) || any(efficiencies > 1))) {\n      stop(\"'efficiencies' must be all in interval [0,1]\")\n    }\n\n    if (is.vector(efficiencies)){\n      if (length(efficiencies) != dim(val.mat)[1]){\n        stop(\"'efficiencies' vector length sould be equal to number of species (dimension of val.mat)\")\n      }\n    } else if (dim(efficiencies != dim(val.mat))){\n      stop(\"'efficiencies' matrix dimension different from 'val.mat'\")\n    }\n  }\n\n  if (!(ef.level %in% c('prey', 'pred', 'link.specific'))){\n    stop(\"ef.level should be set to 'pred', 'prey' or 'link.specific'\")\n  }\n  if (ef.level == 'prey' && is.matrix(efficiencies)){ # if user did not change the ef.level = \"prey\" optional argument but provide a matrix for efficiencies:\n    warning(\"'ef.level' is set to 'prey' and expect a vector of efficiencies but get a matrix instead.\\n ef.level was then set to 'link.specific'\")\n    ef.level = 'link.specific'\n  }\n\n  # growth.rate\n  if (! is.numeric(growth.rate)){\n    stop(\"growth.rate should be numeric\")\n  } else if (any(growth.rate < 0)){\n    stop(\"all growth.rate values are expected to be positive (or 0)\")\n  }\n  if (!is.vector(growth.rate)){\n    stop(\"growth.rate should be a vector\")\n  } else if (length(growth.rate) != sum(colSums(val.mat) == 0)){\n    stop(\"length of growth.rate vector should be equal to the number of primary producer (species with no prey)\")\n  }\n\n  ### define loss vector as the sum of species losses:\n  if (! is.vector(losses)){\n    losses = rowSums(losses)\n  }\n  if (bioms.losses == T){\n    losses = losses*biomasses\n  }\n\n  nb_s = dim(val.mat)[1]\n  nb_b = sum(colSums(val.mat) == 0)\n  jacob = matrix(0, nb_s, nb_s)\n  jacob = create.jacob(val.mat, biomasses, losses, efficiencies, growth.rate, bioms.prefs = TRUE, bioms.losses = TRUE, ef.level = \"prey\")\n\n  # return(eigen(jacob))\n  if (full.output){\n    # should also return the jacobian\n    return(eigen(jacob))\n  } else{\n    return(max(Re(eigen(jacob)$values)))\n  }\n}\n\n\n#' making network stability\n#'\n#' Find the smallest multiplicator of a variable from losses insuring system stability - !Version under devlopment!\n#'\n#' @param val.mat A matrix describing fluxes between species (usually a result of \\code{\\link[fluxweb]{fluxing}} function).\n#' @param biomasses A vector of species biomasses.\n#' @param losses A vector or an array of species energy losses (excluding predation).\n#' @param efficiencies A vector or an array of conversion efficiencies of species in the adjacency matrix. These values describe the proportion of consumed energy that is converted to biomass of the consumer.\n#' @param growth.rate A vector defining growth rate of basal species.\n#' @param losses.scale Defines a Column from \\code{losses} mulitplicator value will apply to. (default \\code{NULL} if multiplicator independant of losses).\n#' @param bioms.prefs Logical, if \\code{TRUE} (default) preferences are scaled accordingly to species biomasses.\n#' @param bioms.losses Logical, if \\code{TRUE} (default) losses are scaled with biomass.\n#' @param ef.level Set to \\code{\"prey\"} if efficiences are defined by prey, \\code{\"pred\"} if they are a property of the predator.\n#' @param interval Search interval for returned value.\n#' @param ... Optional parameters for function \\code{\\link[stats]{uniroot}}\n#'\n#'\n#' @return\n#' A list from \\code{\\link[stats]{uniroot}} function.\n#'\n#' @details\n#' The function assume a monotonous increase of stability with multiplicator value. Solution is estimated from the \\code{\\link[stats]{uniroot}} function, and stability using the \\code{\\link[fluxweb]{fluxing}} function\n#' Thus, accordingly to \\code{\\link[stats]{uniroot}} solving criteria, if stability values at the two extremu parts of the interval are of same sign, an error is raised.\n#'\n#' Behavior of the multiplicative term depends on the type of losses:\n#' \\itemize{\n#' \\item{\\code{losses.scale = NULL} and \\code{is.vector(losses)}:} multiplicator will be applied to the \\code{losses} vector.\n#' \\item{\\code{losses.scale = NULL} and \\code{is.matrix(losses)}:} multiplicator will be independant of any columns from \\code{losses}.\n#' \\item{\\code{losses.scale = FALSE} :} multiplicator always independant of losses.\n#' \\item{other values:} should refer to an element of losses.\n#'\n#' This is an ugly part, but I don't see how to do better right now. Any ideas?\n#'\n#' }\n#'\n#' @seealso \\code{\\link[stats]{uniroot}} for root estimate and \\code{\\link[fluxweb]{stability.value}} for assessing system stability.\n#'\n#'\n#' @examples\n#'\n#'mat = matrix(0, 5, 5)\n#'mat[2,1] = 1\n#'mat[5,1] = 1\n#'mat[3,2] = 1\n#'mat[4,2] = 1\n#'\n#'# metabolic losses:\n#'losses = c(0.6299, 0.25, 0.12, 0.15, 0.1)\n#'\n#'# biomasses\n#'biomasses = c(1.5, 1.51, 1.8, 1.5, 2)\n#'\n#'# efficiencies\n#'efficiencies = c(0.85, 0.85, 0.35, 0.35, 0.35)\n#'# growth rates of basal sppecies\n#'growth.rates = c(0.28, 0.32, 0.19)\n#'losses = c(0.64, 0.4, 0.25, 0.3, 0.1)\n#'val.mat = fluxing(mat, biomasses, losses, efficiencies, bioms.pref = TRUE, ef.level = \"pred\")\n#'make.stability(val.mat, biomasses, losses, efficiencies, growth.rates, ef.level = \"pred\")\n#'\n#'\n#' @export\n#'\n#'\n\nmake.stability = function(val.mat,\n                          biomasses,\n                          losses,\n                          efficiencies,\n                          growth.rate,\n                          losses.scale = NULL,\n                          bioms.prefs = TRUE,\n                          bioms.losses = TRUE,\n                          ef.level = \"prey\",\n                          interval = c(1e-12,1),\n                          ...){\n\n  stability.value.wrapper = function(x, unvariant, col, val.mat, biomasses, efficiencies, growth.rate, bioms.prefs, bioms.losses, ef.level){\n    tot.losses = x*col + unvariant\n    return(stability.value(val.mat, biomasses, tot.losses, efficiencies, growth.rate, bioms.prefs, bioms.losses, ef.level))\n  }\n\n  # mat\n  if (! is.numeric(val.mat)){\n    stop(\"'val.mat' must be numeric\")\n  }\n  if (dim(val.mat)[1] != dim(val.mat)[2]){\n    stop(\"val.mat should be a square matrix\")\n  }\n  nb_s = dim(val.mat)[1]\n  # biomasses\n  if (! is.vector(biomasses)){\n    stop(\"biomasses should be a vector\")\n  } else{\n    if (length(biomasses) != dim(val.mat)[1]){\n      stop(\"length of biomasses vector should equal to dimensions of val.mat\")\n    }\n  }\n  if (! is.numeric(biomasses)){\n    stop(\"'biomasses' must be numeric\")\n  } else if (any(biomasses <= 0)){\n    stop(\"'biomasses' must be all >0\")\n  }\n\n  # losses\n  if (! is.numeric(losses)){\n    stop(\"'losses' should be numeric\")\n  } else if (any(losses < 0)){\n    stop(\"'losses' contain negative value(s)\")\n  }\n\n  # efficiences\n  if (! is.numeric(efficiencies)){\n    stop(\"'efficiencies' must be numeric\")\n    if (!(any(efficiencies < 0) || any(efficiencies > 1))) {\n      stop(\"'efficiencies' must be all in interval [0,1]\")\n    }\n\n    if (is.vector(efficiencies)){\n      if (length(efficiencies) != dim(val.mat)[1]){\n        stop(\"'efficiencies' vector length sould be equal to number of species (dimension of val.mat)\")\n      }\n    } else if (dim(efficiencies != dim(val.mat))){\n      stop(\"'efficiencies' matrix dimension different from 'val.mat'\")\n    }\n  }\n\n  #ef.level\n  if ((ef.level != \"prey\") && (ef.level != \"pred\")){\n    stop(\"ef.level should be either 'pred' or 'prey'\")\n  }\n\n  # growth.rate\n  if (! is.numeric(growth.rate)){\n    stop(\"growth.rate should be numeric\")\n  } else if (any(growth.rate < 0)){\n    stop(\"all growth.rate values are expected to be positive (or 0)\")\n  }\n  if (!is.vector(growth.rate)){\n    stop(\"growth.rate should be a vector\")\n  } else if (length(growth.rate) != sum(colSums(val.mat) == 0)){\n    stop(\"length of growth.rate vector should be equal to the number of primary producer (species with no prey)\")\n  }\n\n  # compute losses\n  # here, operation is:\n  # final.losses = colSums(invariant + value*col), where value is the value to estimate\n\n  if (missing(losses.scale)){\n    if (is.vector(losses)){\n      unvariant = rep(0, nb_s)\n      col = losses\n    }\n    if (is.matrix(losses)){\n      #generate a warning as behaviour will be the same as losses.scale = false?\n      unvariant = colSums(losses)\n      col = rep[1, nb_s]\n    }\n  } else{\n    if (is.numeric(losses.scale) && !is.integer(losses.scale)){\n      stop(\"losses.scale should be a either character or non integer numeric\")\n    }\n    if (is.vector(losses) && losses.scale == FALSE){\n      unvariant = losses\n      col = rep(1, nb_s)\n    }\n    if (is.matrix(losses) && losses.scale == FALSE){\n      unvariant = colSums(losses)\n      col = rep(1, nb_s)\n    }\n    if (is.matrix(losses) && is.integer(losses.scale)){\n      if ((losses.scale <1 ) || (losses.scale > dim(val.mat[1]))){\n        stop(\"losses.scale should be between 1 and species number\")\n      }\n      col = losses[,losses.scale]\n      unvariant = colSums(losses[, -losses.scale])\n    }\n    if (is.matrix(losses) && is.character(losses.scale)){\n      if (!(losses.scale %in% names(losses))){\n        stop(\"losses.scale not a column name of losses\")\n      }\n      col = losses[,names(losses.scale) == losses.scale]\n      unvariant = colSums(losses[, colnames(losses) != losses.scale])\n    }\n  }\n\n  # get stability values to at the interval boundaries\n  stab.upper = stability.value.wrapper(max(interval), unvariant, col, val.mat, biomasses, efficiencies, growth.rate, bioms.prefs, bioms.losses, ef.level)\n  stab.lower =  stability.value.wrapper(min(interval), unvariant, col, val.mat, biomasses, efficiencies, growth.rate, bioms.prefs, bioms.losses, ef.level)\n\n  if (stab.lower < 0 && stab.upper <0){\n    stop(\"unable to assess minimal stability value: system always stable in specified interval.\")\n  }\n   if (stab.lower > 0 && stab.upper > 0){\n    stop(\"unable to assess minimal stability value: system never stable: system never stable in specified interval.\")\n  }\n\n  min.stab.value = stats::uniroot(stability.value.wrapper, interval, ..., unvariant, col, val.mat, biomasses, efficiencies, growth.rate, bioms.prefs, bioms.losses, ef.level,\n                           lower = min(interval), upper = max(interval), f.lower = stab.lower, f.upper = stab.upper)\n  return(min.stab.value)\n\n}\n\n\n#' Internal function to compute jacobian\n#'\n#'@keywords internal\n#'\n#'\n#'\n\ncreate.jacob = function(val.mat, biomasses, losses, efficiencies, growth.rate, bioms.prefs = TRUE, bioms.losses = TRUE, ef.level = \"prey\"){\n  nb_s = dim(val.mat)[1]\n  nb_b = sum(colSums(val.mat) == 0)\n  jacob = matrix(0, nb_s, nb_s)\n  basal.index = which(colSums(val.mat) == 0) # store the position of basal species in arguments\n    for (i in 1:nb_s){\n      for (j in 1: nb_s){\n        if (i == j){\n          if (i %in% basal.index){ # then species i is basal\n            jacob[i,j] = growth.rate[which(basal.index == i)] - sum(val.mat[i,])/biomasses[i]\n          } else{\n            if (ef.level == \"pred\") {\n            jacob[i,j] = -losses[i] + val.mat[i,j] * (efficiencies[i] - 1) / biomasses[i] +\n              efficiencies[i] * sum(val.mat[,i])/biomasses[i] - sum(val.mat[i,]) / biomasses[i]\n            }\n            if (ef.level == \"prey\" && is.vector(efficiencies)){\n              jacob[i,j] = -losses[i] + val.mat[i,j] * (efficiencies[i] - 1) / biomasses[i] +\n                sum(val.mat[,i] * efficiencies) / biomasses[i] - sum(val.mat[i,]) / biomasses[i]\n            }\n            # should change the following line to consider a flag for efficiencies = \"link.level\" instead of checking if it's a matri or not\n            if (ef.level == \"link.specific\"){\n              jacob[i,j] = -losses[i] + val.mat[i,j] * (efficiencies[i,i] - 1) / biomasses[i] +\n                sum(val.mat[,i] * efficiencies[,i]) / biomasses[i] - sum(val.mat[i,]) / biomasses[i]\n            }\n          }\n        } else{\n          if (ef.level == \"pred\") {jacob[i,j] = (efficiencies[i]*val.mat[j,i] - val.mat[i,j])/biomasses[j]}\n          if (ef.level == \"prey\" && is.vector(efficiencies)) {jacob[i,j] = (efficiencies[j]*val.mat[j,i] - val.mat[i,j])/biomasses[j]}\n          # should change the following line to consider a flag for efficiencies = \"link.level\" instead of checking if it's a matri or not\n          if (ef.level == \"link.specific\") {jacob[i,j] = (efficiencies[j,i]*val.mat[j,i] - val.mat[i,j])/biomasses[j]}\n        }\n      }\n    }\n  return(jacob)\n}\n\n",
    "created" : 1506676435481.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2582934094",
    "id" : "6B6CFBF4",
    "lastKnownWriteTime" : 1506676463,
    "last_content_update" : 1506676463127,
    "path" : "~/projects/fluxing_webs/fluxweb/R/stability.R",
    "project_path" : "R/stability.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}