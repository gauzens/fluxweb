# SEW05  nb links: 1239  nb species:  101  nb of deleted species:  34
# SEW08  nb links: 1897  nb species:  118  nb of deleted species:  38
# AEW49  nb links: 2883  nb species:  152  nb of deleted species:  45
# here is the food web to use
chosen.one = 'SEW36'
# restrict data to the selected food web
web.links = tab.link[tab.link$foodweb.name == chosen.one, ]
web.info = tab.info[tab.info$plot == chosen.one, ]
species = sort(unique(c(as.character(web.links$res.taxonomy), as.character(web.links$con.taxonomy))))
nb_s = length(species)
# species.info = unique(web.info$species)
# species[!(species %in% species.info)]
# species.info[!(species.info %in% species)]
basales = unique(web.links$res.taxonomy[!(web.links$res.taxonomy %in% web.links$con.taxonomy)])
basales
# create vectors about species information (bsases / non basales, trophic levels, body mass, biomass)
status = c()
for (sp in species){
if (sp %in% basales){
status = c(status, 'basal')
}else{
status = c(status, 'non_basal')
}
}
# tls = rep(NA, length(species))
# for (i in 1:length(species)){
#   if (status[i] == 'basal'){
#     tls[i] = 0
#   }else{
#     if (species[i] %in% unique(web.info$species)){
#       tls[i] = unique(web.info$trophic.level[web.info$species == species[i]])
#     }
#   }
# }
bioms = c()
BM = c()
for (sp in species){
if (sp %in% web.info$species){
bioms = c(bioms, unique(web.info$biomass[web.info$species == sp]))
BM = c(BM, unique(web.info$bodymass.mg[web.info$species == sp]))
} else{
bioms = c(bioms, NA)
BM = c(BM, NA)
}
}
# so far, I lack information for some species (non basales species in the food web data base not in species.info)
# should estimate their biomass / bodymass form general regression.
# for basal ones, I can assign them 1, as their value is neutral regarding the fluxing method
bioms[status == 'basal'] = 1
BM[status == 'basal'] = 1
bioms[species == 'bacteria'] = 15
# species[is.na(bioms)]
# for some species, there is supplementary info in the food web database:
for (i in 1:length(species)){
if (is.na(BM[i])){
if (species[i] %in% web.links$res.taxonomy){
BM[i] = unique(web.links$res.mass.mean.g.[web.links$res.taxonomy == sp])
}
if (species[i] %in% web.links$con.taxonomy){
BM[i] = unique(web.links$con.mass.mean.g.[web.links$con.taxonomy == sp])
}
}
}
# all body masses are complete now. I only lack some biomass data for these species:
# species[is.na(bioms)]
## create food web matrix
mat = matrix(0, length(species), length(species))
pred = web.links$con.taxonomy
prey = web.links$res.taxonomy
comp = 0
for (i in 1:length(pred)){
mat[match(prey[i], species), match(pred[i], species)] = 1
comp = comp + 1
}
mat2 = mat[-which(is.na(bioms)), -which(is.na(bioms))]
bioms2 = bioms[!is.na(bioms)]
species2 = species[!is.na(bioms)]
BM2 = BM[!is.na(bioms)]
status2 = status[!is.na(bioms)]
first_extinction = species[is.na(bioms)]
# secondary extinctions: non basal species without prey
while (any(colSums(mat2) == 0 & status2 == 'non_basal')){
to_delete = which(colSums(mat2) == 0 & status2 == 'non_basal')
mat2 = mat2[-to_delete, -to_delete]
status2 = status2[-to_delete]
bioms2 = bioms2[-to_delete]
BM2 = BM2[-to_delete]
species2 = species2[-to_delete]
}
sec_exct = species2[colSums(mat2) == 0 & status2 == 'non_basal']
# but several isolated species, that will be removed using nw
isol = species2[colSums(mat2) == 0 & rowSums(mat2) == 0]
if (length(isol) > 0) {
isol.index = which(colSums(mat2) == 0 & rowSums(mat2) == 0)
mat2 = mat2[-isol.index, -isol.index]
species2 = species2[-isol.index]
BM2 = BM2[-isol.index]
bioms2 = bioms2[-isol.index]
}
deleted = species[!(species %in% species2)]
write.table(mat2, paste('/homes/bg33novu/projects/fluxing_webs/example/', chosen.one, sep = ""), row.names = as.character(species2), col.names = F, sep = "\t", eol = '\n', fileEncoding = "UTF-8" )
mat.species = mat2
biomass.species = bioms2
BodyMass.species = BM2
species.names = noquote(species2)
MetRate.species = 0.14*BodyMass.species^(-0.25)
# defining bioms and BM for the functional groups
species.tgs = read.table('/homes/bg33novu/projects/fluxing_webs/example/TLs_SEW36.txt', sep = ',', header = TRUE)
tgs = unique(species.tgs$TroG)
biomass.tgs = rep(NA, length(tgs))
BodyMass.tgs = rep(NA, length(tgs))
for (i in 1:length(tgs)){
sps = species.tgs$Species[species.tgs$TroG == i]
biomass.tgs[i] = sum(biomass.species[species.names %in% sps])
BodyMass.tgs[i] = mean(BodyMass.species[species.names %in% sps])
}
mat.funcGrps = as.matrix(read.table('/homes/bg33novu/projects/fluxing_webs/example/TG_Mat_SEW36.txt', sep = ","))
colnames(mat.funcGrps) = NULL
biomass.species
?apply
?sweep
devtools::document()
devtools::build()
#' generate fluxes
#'
#' create a valuated graph adjacency matrix from its binary version
#'
#' @param mat Network adjacency matrix describing interactions among species. Interactions can be either binary or weighted.
#' @param losses A vector or an array of species energy losses (excluding predation).
#' @param biomasses Vector of species biomasses.
#' @param efficiencies A vector or an array of conversion efficiencies of species in the adjacency matrix. These values describe the proportion of consumed energy that is converted to biomass of the consumer.
#' @param bioms.prefs Logical - if \code{TRUE}, consumer preferences are scaled according to species biomasses.
#' @param bioms.losses Logical - if \code{TRUE}, losses are scaled with species biomasses.
#' @param ef.level Set to \code{"prey"} if efficiences are defined by prey, \code{"pred"} if they are a property of the predator.
#'
#'
#' @return Returns an adjacency matrix where entries are the computed energy fluxes between consumer species and their respective resources.
#'
#'
#'@details
#'This function compute fluxes in food webs based on an equilibrium hypothesis: for each species, sum of ingoing fluxes (gains from predation) balances the sum of outgoing fluxes.
#'Outgoing fluxes are defined by predation and \code{losses} argument. Ususally \code{losses} relate to species metabolic rates and/or natural death rates. for each species \code{i}, sum of ingoing fluxes \code{F_i} is computed as:
#'\deqn{
#'F_{i} = \frac{1}{e_i} (L_i + \sum_j W_{ij}F_j) \quad if \quad \code{ef.level == "pred"}
#'}
#'\deqn{
#'F_{i} = \frac{L_i + \sum_j W_{ij}F_j}{\sum_j W_{ji}e_j} \quad if \quad \code{ef.level == "pred"}
#'}
#'\code{W} set the matrix of preferences estimated from \code{mat}, accordingly to \code{bioms.prefs}. \code{L} is the vector depicting sum of losses
#'(scaled or not by biomasses, accordingly to \code{bioms.losses}) and \code{e} is the vector of species efficiencies.
#'
#'
#'\itemize{
#'\item{\code{mat}:} Either a binary or a valuated matrix can be used. A non zero value for mat[i,j] means that species i is consumed by species j.
#'Matrix entries would assess predator preferences on its prey, thus providing a binary matrix assume no preferences.
#'
#'\item{\code{losses}:} express species energetic losses not related to predation. Usually metabolic or death rates.
#'When an array is provided, losses associated to each species correspond to line sums.
#'
#'\item{\code{efficiencies}:} Determines how efficient species are to convert energy (see \code{ef.level} for more details).
#'Providing an array will assume values depending on both prey and predator identity
#'
#'\item{\code{bioms.pref}:} If \code{TRUE}, preferences \eqn{W_{ij}} of predator j on prey i are scaled accordingly to species biomass unsing the following formula:
#'\deqn{
#'W_{i,j} = \frac{mat[i,j] * biomasses[i]}{\sum_k mat[i,k]* biomasses[k]}
#'}
#'If \code{FALSE}, a mormalisation on column values is performed.
#'
#'\item{\code{bioms.losses}:} Set to true, function will assume that losses are defined per biomass unit.
#'Thus, total losses will be thereafter multiplied by biomass values for each species.
#'
#'\item{\code{ef.level}:} if \code{"prey"} (resp \code{"pred"}), the total amount of energy that can be metabolised from a trophic link
#'will be determined by prey (resp pred) identity. \code{"link.specific"} assumes that efficiencies are defined for each trophic interaction
#'and ask \code{efficiencies} parameter to be a matrix
#'
#'}
#'
#'
#' @examples
#' # first compute species per unit biomass metabolic rates using the metabolic theory:
#'losses = 0.1 * species.level$bodymasses^(-0.25)
#'
#' # Then assess prey efficiencies (0.35 for basal species, 0.85 for non basal)
#'efficiencies = rep(NA, length(species.level$names))
#'efficiencies[colSums(species.level$mat) == 0] = 0.35
#'efficiencies[colSums(species.level$mat) > 0] = 0.85
#'
#'# call of the function:
#'fluxing(species.level$mat, species.level$biomasses, losses, efficiencies, bioms.pref = TRUE, ef.level = "prey")
#'
#' @export
#'
#'
#' @author Benoit gauzens, \email{benoit.gauzens@gmail.com}
fluxing = function(mat, biomasses = NULL, losses, efficiencies, bioms.prefs = TRUE, bioms.losses = TRUE, ef.level = "prey"){
# mat
if (! is.numeric(mat)){
stop("'mat' must be numeric")
}
if (dim(mat)[1] != dim(mat)[2]){
stop("mat should be a square matrix")
}
# biomasses
if (!is.null(biomasses)){
if (! is.vector(biomasses)){
stop("biomasses should be a vector")
} else{
if (length(biomasses) != dim(mat)[1]){
stop("length of biomasses vector should equal to dimensions of mat")
}
}
if (! is.numeric(biomasses)){
stop("'biomasses' must be numeric")
} else if (any(biomasses < 0)){
stop("'biomasses' must be all >=0")
}
} else if (bioms.prefs){
stop("bioms.prefs set to TRUE but no biomasses provided")
}
# losses
if (! is.numeric(losses)){
stop("'losses' should be numeric")
} else if (any(losses < 0)){
stop("'losses' contain negative value(s)")
}
# efficiences
if (! is.numeric(efficiencies)){
stop("'efficiencies' must be numeric")
if (!(any(efficiencies < 0) || any(efficiencies > 1))) {
stop("'efficiencies' must be all in interval [0,1]")
}
if (is.vector(efficiencies)){
if (length(efficiencies) != dim(mat)[1]){
stop("'efficiencies' vector length sould be equal to number of species (dimension of mat)")
}
} else if (dim(efficiencies != dim(mat))){
stop("'efficiencies' matrix dimension different from 'mat'")
}
}
if (!(ef.level %in% c('prey', 'pred', 'link.specific'))){
stop("ef.level should be set to 'pred', 'prey' or 'link.specific'")
}
if (ef.level == 'prey' && is.matrix(efficiencies)){ # if user did not change the ef.level = "prey" optional argument but provide a matrix for efficiencies:
warning("'ef.level' is set to 'prey' and expect a vector of efficiencies but get a matrix instead.\n ef.level was then set to 'link.specific'")
ef.level = 'link.specific'
}
### first arrange mat: apply the biomass scaling of preferences if needed
### columns should sum to 1 for predators, 0 to preys
column.sum = colSums(mat)
if (bioms.prefs){
# 'apply functional' response of preferencs
# mat[, column.sum > 0] = apply(mat[, column.sum > 0], 2, function(vec, bioms) vec*biomasses/sum(vec*biomasses), biomasses) #! in the function I should use bioms instead biomasses
mat[, column.sum > 0] = apply(mat[, column.sum > 0], 2, function(vec) vec*biomasses/sum(vec*biomasses)) #! in the function biomasses is already defined more globaly, so no need of another parameter
} else { # here optimise with else if not all element of colsums are equal to either 1 or 0...
# sum of entries have to sum to one for each predator (normalisaton of preferences)
colomn.sum = colSums(mat)
mat[, colomn.sum>0] = sweep(mat[, colomn.sum>0], 2, colomn.sum[colomn.sum>0], "/")
}
### define loss vector as the sum of species losses:
# need to check data input much more carefully...
if (! is.vector(losses)){ # this is for allowing user to input a loss matrix (different kinds of physiological loss in the same parameter)
losses = rowSums(losses)
}
if (bioms.losses == T){
losses = losses*biomasses
}
### then solving the system
# warning here: even if efficiencies are defined at the predator level I need a vector of legth = to number of species (with some arbitrary values for basal species)
# should be precised somewhere
if (ef.level == "pred"){
F = solve(diag(efficiencies) - mat) %*% losses
}
if (ef.level == "prey"){
vec.in = as.vector(t(mat) %*% efficiencies)
vec.1p = rep(0, dim(mat)[1])
vec.1p[colSums(mat) == 0] = 1
F = solve(diag(vec.in + vec.1p) - mat) %*% losses
}
if (ef.level == "link.specific"){
U = mat * efficiencies
vec.one = rep(1, dim(efficiencies)[1])
vec.1p = rep(0, dim(mat)[1])
vec.1p[colSums(mat) == 0] = 1
vec.in = as.vector(t(U)%*%vec.one + vec.1p)
F = solve(diag(vec.in) - mat) %*% losses
}
### set individual fluxes (each element of ith line from mat.norm is multiplied bu the ith element of F)
flux.mat = sweep(mat, 2, F, "*")
return(flux.mat)
}
# first compute species per unit biomass metabolic rates using the metabolic theory:
losses = 0.1 * species.level$bodymasses^(-0.25)
# Then assess prey efficiencies (0.35 for basal species, 0.85 for non basal)
efficiencies = rep(NA, length(species.level$names))
efficiencies[colSums(species.level$mat) == 0] = 0.35
efficiencies[colSums(species.level$mat) > 0] = 0.85
# call of the function:
fluxing(species.level$mat, species.level$biomasses, losses, efficiencies, bioms.pref = TRUE, ef.level = "prey")
devtools::document()
devtools::build()
devtools::document()
species.level
colSums(species.level$mat)
a = c(1,2,3,4,5,6,7)
wich(a == 1)
which(a == 1)
which(a == 7)
a[2] = 1
which(a == 1)
a = c(4, 12, 3)
which(a == 4)
which(a == 12)
devtools::document()
devtools::build()
devtools::document()
devtools::document()
devtools::build()
devtools::document()
devtools::document()
devtools::build()
devtools::document()
devtools::document()
devtools::build()
devtools::document()
sensitivity = function(fun.name, param.name, var, n, full.output = FALSE, ...){
is.scalar = function(x){
return(is.vector(x) && length(x) == 1)
}
# get arguments for fun.name
args = list(...)
# store result from the function without any randomness
res.init = do.call(fun.name, args)
# creates vector of results
if (full.output){
if (is.scalar(res.init)){
res.output = rep(NA, n)
}else{
res.output = list()
}
}
vec.cv = rep(NA, n)
simple.res = 0
for (i in 1:n){
## first, modification of the focal parameter
if (is.matrix(args[[param.name]])){
param = args[[param.name]]
# fill deviation matrix with uniform distribution in [-var, var]
deviation = matrix(stats::runif(dim(param)[1]*dim(param)[1], min = 1 - var, max = 1 + var), dim(param)[1], dim(param)[1])
# output = initial value * deviation
args[[param.name]] = args[[param.name]] * (deviation)
}
if (is.vector(args[[param.name]])){ # scalars are also vectors...
param = args[[param.name]]
# fill deviation vector with uniform distribution in [-var, var]
deviation = stats::runif(length(param), min = 1 - var, max = 1 + var)
# output = initial value * deviation
args[[param.name]] = args[[param.name]] * (deviation)
# print(args[[param.name]])
}
## then call to the function
res = do.call(fun.name, args)
neutral.res = res.init
neutral.res[neutral.res == 0] = NA
# then, for this draw, departure is the coefficient of variation (base = results without random variation)
# for matrix or vector, I take the mean value of all cv
res.cv = abs((res - res.init)/neutral.res)
if (full.output){
if (is.scalar(res.init)){
res.output[i] = res.cv
}else{
res.output[[i]] = res.cv
}
}
#  sensitivity value is then the means of the coefficient of variation
simple.res = simple.res + res.cv/n
}
if (full.output){
return(res.output)
}else{
return(simple.res)
}
}
fluxing = function(mat, biomasses = NULL, losses, efficiencies, bioms.prefs = TRUE, bioms.losses = TRUE, ef.level = "prey"){
# mat
if (! is.numeric(mat)){
stop("'mat' must be numeric")
}
if (dim(mat)[1] != dim(mat)[2]){
stop("mat should be a square matrix")
}
# biomasses
if (!is.null(biomasses)){
if (! is.vector(biomasses)){
stop("biomasses should be a vector")
} else{
if (length(biomasses) != dim(mat)[1]){
stop("length of biomasses vector should equal to dimensions of mat")
}
}
if (! is.numeric(biomasses)){
stop("'biomasses' must be numeric")
} else if (any(biomasses < 0)){
stop("'biomasses' must be all >=0")
}
} else if (bioms.prefs){
stop("bioms.prefs set to TRUE but no biomasses provided")
}
# losses
if (! is.numeric(losses)){
stop("'losses' should be numeric")
} else if (any(losses < 0)){
stop("'losses' contain negative value(s)")
}
# efficiences
if (! is.numeric(efficiencies)){
stop("'efficiencies' must be numeric")
if (!(any(efficiencies < 0) || any(efficiencies > 1))) {
stop("'efficiencies' must be all in interval [0,1]")
}
if (is.vector(efficiencies)){
if (length(efficiencies) != dim(mat)[1]){
stop("'efficiencies' vector length sould be equal to number of species (dimension of mat)")
}
} else if (dim(efficiencies != dim(mat))){
stop("'efficiencies' matrix dimension different from 'mat'")
}
}
if (!(ef.level %in% c('prey', 'pred', 'link.specific'))){
stop("ef.level should be set to 'pred', 'prey' or 'link.specific'")
}
if (ef.level == 'prey' && is.matrix(efficiencies)){ # if user did not change the ef.level = "prey" optional argument but provide a matrix for efficiencies:
warning("'ef.level' is set to 'prey' and expect a vector of efficiencies but get a matrix instead.\n ef.level was then set to 'link.specific'")
ef.level = 'link.specific'
}
### first arrange mat: apply the biomass scaling of preferences if needed
### columns should sum to 1 for predators, 0 to preys
column.sum = colSums(mat)
if (bioms.prefs){
# 'apply functional' response of preferencs
# mat[, column.sum > 0] = apply(mat[, column.sum > 0], 2, function(vec, bioms) vec*biomasses/sum(vec*biomasses), biomasses) #! in the function I should use bioms instead biomasses
mat[, column.sum > 0] = apply(mat[, column.sum > 0], 2, function(vec) vec*biomasses/sum(vec*biomasses)) #! in the function biomasses is already defined more globaly, so no need of another parameter
} else { # here optimise with else if not all element of colsums are equal to either 1 or 0...
# sum of entries have to sum to one for each predator (normalisaton of preferences)
colomn.sum = colSums(mat)
mat[, colomn.sum>0] = sweep(mat[, colomn.sum>0], 2, colomn.sum[colomn.sum>0], "/")
}
### define loss vector as the sum of species losses:
# need to check data input much more carefully...
if (! is.vector(losses)){ # this is for allowing user to input a loss matrix (different kinds of physiological loss in the same parameter)
losses = rowSums(losses)
}
if (bioms.losses == T){
losses = losses*biomasses
}
### then solving the system
# warning here: even if efficiencies are defined at the predator level I need a vector of legth = to number of species (with some arbitrary values for basal species)
# should be precised somewhere
if (ef.level == "pred"){
F = solve(diag(efficiencies) - mat) %*% losses
}
if (ef.level == "prey"){
vec.in = as.vector(t(mat) %*% efficiencies)
vec.1p = rep(0, dim(mat)[1])
vec.1p[colSums(mat) == 0] = 1
F = solve(diag(vec.in + vec.1p) - mat) %*% losses
}
if (ef.level == "link.specific"){
U = mat * efficiencies
vec.one = rep(1, dim(efficiencies)[1])
vec.1p = rep(0, dim(mat)[1])
vec.1p[colSums(mat) == 0] = 1
vec.in = as.vector(t(U)%*%vec.one + vec.1p)
F = solve(diag(vec.in) - mat) %*% losses
}
### set individual fluxes (each element of ith line from mat.norm is multiplied bu the ith element of F)
flux.mat = sweep(mat, 2, F, "*")
return(flux.mat)
}
# first compute species per unit biomass metabolic rates using the metabolic theory:
losses = 0.1 * species.level$bodymasses^(-0.25)
# Then assess prey efficiencies (0.35 for basal species, 0.85 for non basal)
efficiencies = rep(0, length(species.level$names))
efficiencies[colSums(species.level$mat) == 0] = 0.35
efficiencies[colSums(species.level$mat) > 0] = 0.85
res = sensitivity(fluxing, "mat", 0.1, 5, full.output = TRUE, mat = species.level$mat, biomasses = species.level$biomasses, losses = losses, efficiencies = efficiencies)
res
res = sensitivity(fluxing, "efficiencies", 0.1, 50, mat = species.level$mat, biomasses = species.level$biomasses, losses = losses, efficiencies = efficiencies)
res
devtools::document()
devtools::build()
devtools::document()
devtools::document()
devtools::build()
devtools::document()
devtools::document()
devtools::build()
devtools::document()
devtools::document()
devtools::build()
devtools::document()
devtools::build()
devtools::document()
source('~/projects/fluxing_webs/fluxweb/R/stability.R')
source('~/projects/fluxing_webs/fluxweb/R/stability.R')
source('~/projects/fluxing_webs/fluxweb/R/stability.R')
source('~/projects/fluxing_webs/fluxweb/R/flux.function.R')
source('~/projects/fluxing_webs/fluxweb/R/sensitivity.R')
devtools::build()
devtools::document()
devtools::build()
devtools::build_manual()
devtools::document()
